package fr.enigmacrew.golfcard.game;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

public class Game {
    public enum Phase {
        // Players have to turn cards
        START,
        // Main gameplay
        MAIN,
        // The game has ended
        LASTTURN,
        END
    }

    public ArrayList<GameCard> cardStack = new ArrayList<>();
    public ArrayList<GameCard> cardTrash = new ArrayList<>();
    public ArrayList<GameCard> p1 = new ArrayList<>();
    public ArrayList<GameCard> p2 = new ArrayList<>();

    public boolean p1Turn;
    public int turnId;
    private int nCards;
    public Phase phase;

    public Game(int nCards) {
        this.nCards = nCards;
        reset();
    }

    public boolean step(GameAction action, boolean ai) {
        /*
         * Play a game step (turn).
         * Return whether the game is ended.
         */
        ArrayList<GameCard> player = p1Turn ? p1 : p2;

        if (phase == Phase.END) return true;

        // Start phase but p1 has not fully played
        if (action == null && ai && p1Turn) return false;

        if (ai && !p1Turn) {
            if (phase == Phase.START) {
                ++turnId;

                return false;
            }

            action = aiPlay();
        }

        switch (action.kind) {
            case DRAW:
            {
                // Pop
                GameCard card = cardStack.remove(cardStack.size() - 1);
                card.visible = true;

                if (action.targetCard == -1) {
                    // Trash
                    cardTrash.add(card);
                } else {
                    GameCard toTrash = player.get(action.targetCard);
                    toTrash.visible = true;

                    // Replace the target card (put the old card in the trash)
                    cardTrash.add(toTrash);
                    player.set(action.targetCard, card);
                }

                break;
            }
            case TRASH:
            {
                // Pop and replace the target card (put the old card in the trash)
                GameCard card = cardTrash.remove(cardTrash.size() - 1);
                GameCard toTrash = player.get(action.targetCard);

                card.visible = true;
                toTrash.visible = true;

                cardTrash.add(toTrash);
                player.set(action.targetCard, card);

                break;
            }
            case TURN:
            {
                player.get(action.targetCard).visible = true;

                break;
            }
        }

        // Check end
        boolean end = true;
        for (GameCard card : player) {
            if (!card.visible) {
                end = false;
                break;
            }
        }

        // Check deck empty
        if (cardStack.size() == 0)
            refill();

        if (end && phase != Phase.LASTTURN)
            phase = Phase.LASTTURN;

        else if (phase == Phase.LASTTURN)
            phase = Phase.END;

        if (phase == Phase.START) {
            // All initial cards turned
            if (turnId >= nCards / 3 * 2 - 1) {
                phase = Phase.MAIN;
            }

            // Switch player
            if (turnId % (nCards / 3) == nCards / 3 - 1) {
                if (!ai)
                    p1Turn = !p1Turn;
                else {
                    phase = Phase.MAIN;

                    // Play initial moves for the ai
                    for (int i = 0; i < nCards / 3; ++i)  {
                        p1Turn = false;
                        step(null, true);
                    }

                    p1Turn = true;
                }
            }
        } else
            p1Turn = !p1Turn;

        ++turnId;

        return phase == Phase.END;
    }

    private GameAction aiPlay() {
        /*
         * Returns the action generated by the AI
         */
        // All indices where the cards are / aren't visible
        ArrayList<Integer> hiddenCards = new ArrayList<>();
        ArrayList<Integer> visibleCards = new ArrayList<>();
        // ids[card.id] = Number of cards with the same id
        HashMap<String, Integer> p1Ids = new HashMap<>();
        HashMap<String, Integer> p2Ids = new HashMap<>();

        // hiddenCards check
        for (int i = 0; i < p2.size(); ++i)
            (p2.get(i).visible ? visibleCards : hiddenCards).add(i);

        // ids check
        for (GameCard card : p1) {
        	if (card.visible) {
                if (p1Ids.containsKey(card.id))
                    p1Ids.put(card.id, p1Ids.get(card.id) + 1);
                else
                    p1Ids.put(card.id, 1);
        	}
        }

        for (GameCard card : p2) {
        	if (card.visible) {
                if (p2Ids.containsKey(card.id))
                    p2Ids.put(card.id, p2Ids.get(card.id) + 1);
                else
                    p2Ids.put(card.id, 1);
        	}
        }

        // Start phase case
        if (visibleCards.size() == 0)
            // Take the first one
            return new GameAction(GameAction.Kind.TURN, hiddenCards.get(0));

        // Fetch the highest value
        int amax = visibleCards.get(0);
        int valmax = -1;
        for (int c : visibleCards) {
            GameCard card = p2.get(c);
            int val = p2Ids.get(card.id) == 1 ?
                card.value : 0;

            if (val > valmax) {
                amax = c;
                valmax = val;
            }
        }

        if (!cardTrash.isEmpty()) {
            GameCard trash = cardTrash.get(cardTrash.size() - 1);

            // Duplicate card in the trash
            int duplicate = -1;
            for (int card : visibleCards)
                if (p2.get(card).id == trash.id) {
                    duplicate = card;
                    break;
                }

            // Take the card within the trash and replace a visible card
            if (duplicate != -1 && valmax != 0) {
                // Don't replace the duplicate
                if (valmax == trash.value) {
                    int amaxNoDup = -1;
                    int valmaxNoDup = -1;
                    for (int c : visibleCards) {
                        GameCard card = p2.get(c);
                        if (card.value != trash.value && card.value > valmaxNoDup &&
                                p2Ids.get(card.id) == 1) {
                            amaxNoDup = c;
                            valmaxNoDup = card.value;
                        }
                    }

                    // No card with value != 0
                    if (amaxNoDup == -1)
                        return new GameAction(GameAction.Kind.TRASH, hiddenCards.get(0));
                    else
                       return new GameAction(GameAction.Kind.TRASH, amaxNoDup);
                }
                else
                    return new GameAction(GameAction.Kind.TRASH, amax);
            }

            // Trash has a low value compared to a card on the deck
            if (trash.value <= 5 && valmax > trash.value)
                return new GameAction(GameAction.Kind.TRASH, amax);
        }

        GameCard deck = cardStack.get(cardStack.size() - 1);

        // Turn when low values on the deck
        if (valmax <= 5)
            return new GameAction(GameAction.Kind.TURN, hiddenCards.get(0));

        // Draw and replace visible card when high values on the deck
        // TODO : Be careful with p1's cards
        if (deck.value < valmax)
            return new GameAction(GameAction.Kind.DRAW, amax);
        else
            // Trash
            return new GameAction(GameAction.Kind.DRAW, -1);
    }

    public Integer[] getScores() {
        /*
         * Fetch players' scores
         */
        return new Integer[] {
            getScore(p1),
            getScore(p2),
        };
    }

    public void reset() {
        /*
         * Reset the game state.
         * Fill randomly cardStack, cardTrash, p1, p2.
         */

        turnId = 0;
        phase = Phase.START;
        p1Turn = true;

        String[] ids = {
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "J",
            "Q",
            "K",
        };

        GameCard.Color[] colors = {
            GameCard.Color.CLUB,
            GameCard.Color.SPADE,
            GameCard.Color.HEART,
            GameCard.Color.DIAMOND
        };

        // Clear the cards from the possible last game
        cardStack.clear();
        cardTrash.clear();
        p1.clear();
        p2.clear();

        // Generate all cards
        for (String id : ids)
            for (GameCard.Color color : colors)
                cardStack.add(new GameCard(id, color, false));

        // Shuffle and distribute
        Collections.shuffle(cardStack);
        ArrayList<GameCard> players = new ArrayList<GameCard>(
                cardStack.subList(cardStack.size() - nCards * 2, cardStack.size()));

        p1 = new ArrayList<GameCard>(players.subList(0, nCards));
        p2 = new ArrayList<GameCard>(players.subList(nCards, 2 * nCards));
        cardTrash.clear();

        cardStack = new ArrayList<GameCard>(
                cardStack.subList(0, cardStack.size() - nCards * 2));
    }

    public void refill() {
        /*
         * Fill the deck when there is no card in it anymore
         */

        ArrayList<GameCard> tmp = cardStack;
        cardStack = cardTrash;
        cardTrash = tmp;

        Collections.shuffle(cardStack);
        for (GameCard card : cardStack)
            card.visible = false;
    }

    private int getScore(ArrayList<GameCard> cards) {
        int score = 0;
        HashMap<String, Integer> ids = new HashMap<>();

        for (GameCard card : cards) {
        	if(card.visible) {
                if (ids.containsKey(card.id))
                    ids.put(card.id, ids.get(card.id) + 1);
                else
                    ids.put(card.id, 1);
        	}
        }

        for (GameCard card : cards) {
        	if(card.visible) {
                // There is only one card
                if (ids.get(card.id) == 1)
                    score += card.value;
        	}
        }

        return score;
    }
}
